---
title: "Workshop #3: dplyr & ggplot"
author: Lucy Liu
output:
  pdf_document: default
---

#Introduction
The contents of this workshop are adapted from the University of Cambirdge [Bioinformatics training](https://bioinfotraining.bio.cam.ac.uk/) workshop ["Data Manipulation and Visualisation using R"](http://bioinformatics-core-shared-training.github.io/r-intermediate/)

This section is on the R packages 'dplyr' and 'ggplot.' 

Base R: We call R by itself (without adding any packages) 'base R'. It comes with a lot of functions but you can also add to these functions by installing packages. You can think of this as like installing apps on your phone - it adds extra functions.

Packages: You can think of packages as a bundle of functions. The 'dplyr' package is a bundle of functions for manipulating your data. The 'ggplot' is a bundle of functions for making plots and it is one of the most popular packages! They were both written by the same person and they work well together.

#Package installation 
You need to install packages first before you use them. To install a package that you have not used before requires 2 steps:

1. install.packages('dplyr') - This command downloads the package onto your computer (if you are using the server, you don't need to do this as it would already have been done). You only need to do this ONCE.
2. library('dplyr') - This command 'opens' this package up and you need to do this every time you open up R. People using the server you will need to use this command.

#Data import
The data that we are using today can be found [here](https://github.com/bioinformatics-core-shared-training/r-intermediate/blob/master/patient-data-cleaned.txt). 
It's important to have a look at the data before you import it. Ahat symbol is separating each data value and which command should you use to import the data?

To import the data:

1. Save the data as a text file into your working directory.
2. Import your data into R. 

```{r}
patients <- read.csv("patients.txt")
library(dplyr)
library(ggplot2)
```

#DPLYR
A vital function in dplyr is called the 'pipe' %>%
You can think about this as a pipe, that sends data through to the next function. We'll use the function select() to demonstrate this.

##select
The select() function let's you select columns in your data.
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  select(Name)
```
What's happening here, is that we start with our data, the variable called 'patients', we are piping the data to the first function called select() which is selecting just the column named 'Name'. 

To select all columns apart from Name:
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  select(-Name) %>%
  head()
```
You can also get columns within a particular range. This code below selects all columns between Name and Sex.
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  select(Name:Sex) %>%
  head()
```
We can also use ends_with() to select all columns whose name ends with "t".
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  select(ends_with("t")) %>%
  head()
```

##Exercise: select()

1. Select all the columns between Height and Grade_Level
2. Select all the columns between Height and Grade_Level, but NOT Pet
3. Select the columns Height and Weight

##Filter
filter() function let's you choose rows from the data frame. We can use the comparison operators ==, >, < and != to help use choose the rows we want.

To choose all the rows where the patient is male we say that we want the Sex column to be equal (==) to 'Male', like this:
```{r, echo=TRUE, eval=FALSE}
patients %>%
  filter(Sex == 'Male') %>%
  head()
```

To choose all the rows where the patient's name is NOT 'Michael', we say that we want the Name column to not be equal to (!=) 'Michael': 
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  filter(Name != 'Michael') %>%
  head()
```

To choose all the rows where the patient is Male and their Pet is a Dog we do this:
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  filter(Sex == 'Male', Pet == 'Dog') %>%
  head()
```
You can also use & here. It is exactly the same as a comma.

To choose all the rows where the patient's height is above 170 or (symbol for or is '|') their pet is a dog, we use:
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  filter(Height > '170' | Pet == 'Dog') %>%
  head()
```

To choose all the rows where the patient's pet is EITHER a dog or a bird we use:
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  filter(Pet %in% c("Dog", "Bird")) %>%
  head()
```
The %in% function finds matches. It looks for all the rows where the column Pets, matches Dog or bird.

Note that there is a difference between %in% and ==
This:
```{r}
patients %>%
  filter(Pet %in% c("Dog", "Bird"))
```
will not return the same result as this:
```{r}
patients %>%
  filter(Pet == c("Dog", "Bird"))
```

The tip is, when you are looking for more than one thing (e.g. pet is either dog or birth), use %in%. When you are looking for only one thing (e.g. pet is a dog), use ==.

You can combine select and filter together like this:
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  filter(Pet %in% c("Dog", "Bird")) %>%
  select(Name:Sex) %>%
  head()
```
This first chooses the rows where the patient's pet is a dog or a bird and then selects the columns from Name to Sex.


##mutate
mutate() allows you to create a new column and add it to the end of your data frame.

We can make a new column where the height is in metres instead of centimetres. We have given our new column the name "height_in_m" (we can name this anything that we choose) and we have specified that we want the number in the height column divided by 100.
```{r,  eval=FALSE, echo=TRUE}
patients %>%
  mutate(height_in_m = Height/100) %>%
  head()
```

##Challenge: mutate and select

1. Create a new column called BMI which gives the BMIs of all the patients 
2. Choose the rows where the overweight (BMI>25) smokers that are still alive
3. Choose the rows where the Female patients from New York or New Jersey 
4. Choose the columns Name and Sex and the rows where patients are overweight and smokers 

Remember that the order you get R to perform the functions matters. 

##group_by & summarise
The group_by() and summarise() functions are very useful when you use them together. They allow you to compute summary statistics for selected columns in our dataset.

Let's first look at what summarise does by itself.
```{r, echo=TRUE, eval=FALSE}
patients %>%
  summarise(mean_height = mean(Height))
```
It's taken all the heights and given us the mean. Note that it returns just one number.

Now let's have a look at what it does when you use it with group_by:
```{r, echo=TRUE, eval=FALSE}
patients %>%
  group_by(Sex) %>%
  summarise(mean_height = mean(Height))
```
It groups the rows into males and females, and then it has given us the mean height for each group. Note that it returns two numbers as there were two groups.

You can calculate more than one summary statistic as well. Below we are grouping our patients by sex and race (there are 2 sexes and 4 difference races, thus we have 8 groups in total) and then calculating the mean height and weight for each group. Note that we will get 8 numbers because there are 8 groups.
```{r, echo=TRUE, eval=FALSE}
patients %>%
  group_by(Sex, Race) %>%
  summarise(mean_height = mean(Height), mean_weight = mean(Weight))
```

##Challenge: group_by & summarise

1. Use summarise to find the mean height and weight of patients in the patients dataset.
2. Find the mean weight of male and female patients from each state
3. Find the proportion of patients of each sex AND smoking status that are deceased

Hint: TRUE's are stored as the number 1 and FALSE's are stored as the number 0 in R. Thus if we create a vector of TRUE's and FALSE's and then take the mean, we get the proportion of TRUE's in the vector.
```{r, echo=TRUE, eval=FALSE}
a <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
mean(a)
```

##Prepare data for ggplot
For ggplot, we will use the original data we started with and add a BMI column to the end. We will use this dataframe to make plots with ggplot.
```{r, echo=TRUE, eval=FALSE}
patients <- patients %>%
  mutate(BMI = Weight/(Height/100)^2)
```

#ggplot
ggplot is one of the most popular packages in R. The default parameters usually make sense and the default graph is generally quite nice looking. 

Let's start with the basic anatomy of ggplot code - or how to you give R the instructions to make your plot. 
First you must tell ggplot what data you want to plot. Then using the aes (which stands for "aesthetics"), you tell ggplot how to make your graph (i.e. what is on the x and y axis). Finally you tell ggplot what type of plot you want. Note the plus between ggplot and the geom 

For example, let's make a scatter plot first. 
We first tell ggplot that we want to plot the dataframe 'patients', that we want weight to be on the x axis and height on the y and that we want a scatter plot ('geom_point').
```{r, echo=TRUE, eval=FALSE}
library(ggplot2)
ggplot(patients, aes(x=Weight, y=Height)) +
  geom_point()
```

For a scatter plot are a few other things that we can add to aes. This means that we can add extra variables to our scatter plot.
They are size, shape and colour. 

colour changes the colours of the points according to the Sex column of our dataframe.
```{r}
ggplot(patients, aes(x=Weight, y=Height, colour = Sex)) +
  geom_point()
```

##Challenge: ggplot scatter plot

Recreate this plot:
![](plots/)




##Boxplot

How would I make a boxplot of heights for each sex? 
(draw on whiteboard)
```{r}
ggplot(patients, aes(y=Height, x= Sex)) +
  geom_boxplot()
```

If I also wanted the male and female box to be different coloured, I use fill - as in fill these in different colours.

```{r}
ggplot(patients, aes(y=Height, x= Sex, fill = Sex)) +
  geom_boxplot()
```

Why not use colour? Well weirdly, colour does something sligtly different.
```{r}
ggplot(patients, aes(y=Height, x= Sex, colour = Sex)) +
  geom_boxplot()
```
It actually colours in the border whereas fill - fills in on the inside.

You can also get a side-by-side plot using fill.

```{r}
ggplot(patients, aes(y=Height, x= Sex, fill = Race)) +
  geom_boxplot()
```

##Violin plot
A popular variation of the box plot is the violin plot. Instead of geom_boxplot, I put in geom_violin.

```{r}
ggplot(patients, aes(y=Height, x= Sex, colour = Sex)) +
  geom_violin()
```

In a volin plot the width of the violin is proportion to the density of data - i.e. the width is small here thus there are few patients that are 170cm tall but here around 160 a lot of patients are this height.

##Faceting
Faceting splits your graph into separate panels of graphs.

```{r}
ggplot(patients, aes(x= Weight, y = Height)) +
  geom_point() +
  facet_grid(Smokes~Sex)
```
What happens if I switch smokes and sex around?


***
Challenge
***

##Bar plots
Bar plots are pretty popular.

I want a bar plot of mean heights for each race. What I need to do is to calculate the mean height for each race - I want a dataframe that looks like this.

We can do this using dplyr - does anyone remember how? What functions do we use?

```{r}
patients %>%
  group_by(Race) %>%
  summarise(mean_height = mean(Height))
```

Now I want to plot this on a bar plot. Remember that I said these 2 packages work well together? Well you can directly 'pipe' this data to ggplot! 
This actually makes your work less messy - you don't have to save it as a variable first - remember last week when we often ended up saving many many variables - patients_smokes, patients_females, patients_smokes_females.

So now we don't have to tell ggplot what data do use - because the data is being piped in from here. The rest of the command is the same. How would I make a bar plot like this?
Remember in dplyr we use the %>% and in ggplot we change to + - watch out for this!

```{r, eval=FALSE, echo=TRUE}
patients %>%
  group_by(Race) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race)) +
  geom_bar()
```
We have an error! The message is pretty cryptic.

The reason is easier to understand if I show you a barplot that doesn't give an error.

```{r}
ggplot(patients, aes(x=Height)) +
  geom_bar()
```
What has it plotted? 
y = number of patients that had a height of 157, 158..  
What this function has done, is automatically counted how many houses/rows have 1 bd, 2 bd...  
Notice how we only gave it 1 variable - because it's just counting up how many times there is a 1 bd house and putting the count herre - in the y axis.  
Lets look at our previous data again. We are not plotting how many - we want it to plot actually this number here. We can tell it to do so with stat = "identity"

```{r}
patients %>%
  group_by(Race) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race)) +
  geom_bar(stat = 'identity')

```

***
Challenge
***

```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge')
```


##Modifying your plot

Adding labels and changing colours

```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue"), name = 'gender', labels = c('women', 'men')) +
  theme_bw()
```

You can also add THEMES!

##Saving plots
There are 2 ways to save plots. Via Export > save as image.

Or using code. 
Change to .pdf or .png for the type of plot you want.

```{r, eval=FALSE, echo=TRUE}
pdf("myPlot.pdf", width = 10, height = 8, units = "px")

#bmp()
#jpeg()
#png()


#make your plot here
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue"))

dev.off
```
This way is much easier if you are making several plots - you don't have to click through and save every plot. 

***
Challenge: Save your plot and then do challenge 8.
***

##Scales

The last thing we will cover is scales - changing the axis.

###Discrete axis

So here we have a discrete axis - they are categories.
```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue")) +
  scale_x_discrete(limit = c("Black", "Asian"))
```

You can also control what order they appear in. 

You can also change the names.
```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue"))+
  scale_x_discrete(limit = c("Black", "Asian"), labels = c("Afican American", 'Asian'))
```

###Continuous axis
The y axis here is continuous.

You can change the 'breaks'.
```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue")) +
  scale_x_discrete(limit = c("Black", "Asian"), labels = c("Afican American", 'Asian')) +
  scale_y_continuous(breaks = c(50,100,150))
```

You can also change the labels - it doesn't make sense to do so here but just for demonstration.
```{r}
patients %>%
  group_by(Race, Sex) %>%
  summarise(mean_height = mean(Height)) %>%
  ggplot(aes(y=mean_height, x= Race, fill=Sex)) +
  geom_bar(stat = 'identity', position = 'dodge') + 
  labs(title = 'Mean height by Race and Sex', y= "Mean Height") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("gold", "darkblue")) +
  scale_x_discrete(limit = c("Black", "Asian"), labels = c("Afican American", 'Asian')) +
  scale_y_continuous(breaks = c(50,100,150), labels = c('short', 'medium', 'tall'))
```

***
Challenge 9
***


```{r}
ggplot(patients, aes(y=BMI, x = Sex, fill = Smokes)) +
  geom_violin() +
  labs(title = 'BMI by sex and smoking status') +
  theme(plot.title = element_text(hjust = 0.5)) +
   scale_fill_manual(values = c("purple", "gold"), name = 'Smoking status', label = c("Non-smoker", 'Smoker'))

```






